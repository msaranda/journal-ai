---
import Dictation from '../islands/Dictation';

const { session, settings } = Astro.props;
---

<div class="bg-white dark:bg-neutral-950 rounded-xl border border-neutral-200 dark:border-neutral-800">
  <!-- Today's Entries (Collapsed List) -->
  <div id="entries-list" class="border-b border-neutral-200 dark:border-neutral-800 p-4">
    <h3 class="text-lg font-medium text-neutral-900 dark:text-neutral-100 mb-3">
      Journal AI - <span id="current-date"></span>
    </h3>
    <div id="previous-entries" class="space-y-2">
      <!-- Previous entries will be populated here -->
    </div>
  </div>
  
  <!-- Journal Content Area -->
  <div class="p-6">
    <!-- Main Textarea -->
    <div class="mb-4">
      <textarea
        id="journal-content"
        class="w-full min-h-[400px] p-4 bg-neutral-50 dark:bg-neutral-900 rounded-lg 
               border border-neutral-200 dark:border-neutral-800 
               focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400
               text-neutral-900 dark:text-neutral-100 resize-none leading-relaxed text-base"
        placeholder="Start writing your thoughts..."
      ></textarea>
    </div>
    
    <!-- Controls -->
    <div class="flex items-center justify-between gap-4">
      <div class="flex items-center gap-4">
    <Dictation 
      sttEngine={settings.stt_engine}
      sttLanguage={settings.stt_language}
      client:load 
    />
      </div>
      
      <button 
        id="save-entry"
        class="px-6 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition font-medium"
      >
        Save Entry (Ctrl+Enter)
      </button>
    </div>
    
    <!-- Status Display -->
    <div class="mt-4 flex items-center justify-between text-sm text-neutral-500">
      <span id="current-stats">0 words, 0:00</span>
      <span id="save-status">Ready to write</span>
    </div>
  </div>
</div>

<script>
  console.log('ðŸš€ Simple Journal script loading...');
  
  // DOM elements
  const content = document.getElementById('journal-content') as HTMLTextAreaElement;
  const saveButton = document.getElementById('save-entry');
  const saveStatus = document.getElementById('save-status');
  const currentStats = document.getElementById('current-stats');
  const currentDate = document.getElementById('current-date');
  const previousEntries = document.getElementById('previous-entries');
  
  // Entry tracking state
  let entryTracker: EntryTracker | null = null;
  let todaysEntries: any[] = [];
  
  // Entry metadata interface
  interface EntryMetadata {
    started_at: string;
    first_keystroke_at: string | null;
    finished_at: string;
    duration_seconds: number;
    total_keystrokes: number;
    backspaces: number;
    paste_events: number;
    pauses: number[];
    max_pause: number;
    entry_number: number;
    time_since_last_entry: number;
    word_count: number;
    char_count: number;
    line_count: number;
  }
  
  // Entry tracker class
  class EntryTracker {
    private metrics = {
      started_at: '',
      first_keystroke_at: null as string | null,
      keystrokes: 0,
      backspaces: 0,
      paste_events: 0,
      last_keystroke_time: null as number | null,
      pauses: [] as number[]
    };
    
    startTracking() {
      this.metrics.started_at = new Date().toISOString();
      this.metrics.first_keystroke_at = null;
      this.metrics.keystrokes = 0;
      this.metrics.backspaces = 0;
      this.metrics.paste_events = 0;
      this.metrics.last_keystroke_time = null;
      this.metrics.pauses = [];
      console.log('Entry tracking started at:', this.metrics.started_at);
    }
    
    trackKeystroke(event: KeyboardEvent) {
      const now = Date.now();
      
      // Set first keystroke time
      if (!this.metrics.first_keystroke_at) {
        this.metrics.first_keystroke_at = new Date().toISOString();
      }
      
      // Track pause if there was a previous keystroke
      if (this.metrics.last_keystroke_time) {
        const pauseSeconds = (now - this.metrics.last_keystroke_time) / 1000;
        if (pauseSeconds > 3) {
          this.metrics.pauses.push(Math.round(pauseSeconds));
        }
      }
      
      // Count keystrokes and backspaces
      if (event.key === 'Backspace' || event.key === 'Delete') {
        this.metrics.backspaces++;
      } else if (event.key.length === 1 || event.key === 'Enter' || event.key === 'Tab') {
        // Count printable characters, Enter, and Tab as keystrokes
        this.metrics.keystrokes++;
      }
      
      this.metrics.last_keystroke_time = now;
    }
    
    trackPaste() {
      this.metrics.paste_events++;
    }
    
    finishTracking(content: string): EntryMetadata {
      const finished_at = new Date().toISOString();
      const started = new Date(this.metrics.started_at);
      const finished = new Date(finished_at);
      const duration_seconds = Math.round((finished.getTime() - started.getTime()) / 1000);
      
      const words = content.trim().split(/\s+/).filter(w => w.length > 0);
      const word_count = words.length;
      const char_count = content.length;
      const line_count = content.split('\n').length;
      
      const max_pause = this.metrics.pauses.length > 0 ? Math.max(...this.metrics.pauses) : 0;
      
      // Calculate time since last entry
      let time_since_last_entry = 0;
      if (todaysEntries.length > 0) {
        const lastEntry = todaysEntries[todaysEntries.length - 1];
        const lastFinished = new Date(lastEntry.finished_at || lastEntry.started_at);
        time_since_last_entry = started.getTime() - lastFinished.getTime();
      }
      
      return {
        started_at: this.metrics.started_at,
        first_keystroke_at: this.metrics.first_keystroke_at || this.metrics.started_at,
        finished_at,
        duration_seconds,
        total_keystrokes: this.metrics.keystrokes,
        backspaces: this.metrics.backspaces,
        paste_events: this.metrics.paste_events,
        pauses: this.metrics.pauses,
        max_pause,
        entry_number: (todaysEntries.length || 0) + 1,
        time_since_last_entry,
        word_count,
        char_count,
        line_count
      };
    }
  }
  
  // Initialize on DOM ready
  document.addEventListener('DOMContentLoaded', () => {
    initializeApp();
  });
  
  if (document.readyState === 'loading') {
    // DOM is still loading, wait for DOMContentLoaded
  } else {
    // DOM is already loaded
    initializeApp();
  }
  
  async function initializeApp() {
    // Set current date
    if (currentDate) {
      const today = new Date();
      currentDate.textContent = today.toISOString().split('T')[0];
    }
    
    // Load today's entries
    await loadTodaysEntries();
    
    // Set up event listeners
    setupEventListeners();
    
    console.log('Simple journal app initialized');
  }
  
  async function loadTodaysEntries() {
    try {
      const today = new Date().toISOString().split('T')[0];
      const response = await fetch('/api/vault', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'load',
          date: today
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data && data.data) {
          const frontMatter = data.data;
          
          // Check if we have the new format with entries_metadata
          if (frontMatter.entries_metadata && Array.isArray(frontMatter.entries_metadata)) {
            // New format: use entries_metadata and extract content previews
            const content = data.content || '';
            todaysEntries = frontMatter.entries_metadata.map((entry: any) => {
              // Extract content preview for this entry using a more flexible pattern
              // Look for the entry by number, regardless of time format issues
              const entryPattern = new RegExp(`## [^-]+ - Entry ${entry.entry_number}\\n(.+)`);
              const match = content.match(entryPattern);
              let preview = `Entry ${entry.entry_number}`;
              
              if (match && match[1]) {
                const fullText = match[1].trim();
                // Truncate at word boundary to avoid cutting words in half
                if (fullText.length <= 50) {
                  preview = fullText;
                } else {
                  const truncated = fullText.substring(0, 47);
                  const lastSpace = truncated.lastIndexOf(' ');
                  preview = lastSpace > 20 ? truncated.substring(0, lastSpace) + '...' : truncated + '...';
                }
              } else {
                // Fallback: try to find any content section for this entry
                const sections = content.split(/\n---\n/);
                const entrySection = sections.find(section => 
                  section.includes(`Entry ${entry.entry_number}`) && section.includes('##')
                );
                if (entrySection) {
                  const lines = entrySection.split('\n');
                  const contentLine = lines.find(line => 
                    line.trim() && !line.startsWith('##') && !line.startsWith('#')
                  );
                  if (contentLine) {
                    const fullText = contentLine.trim();
                    if (fullText.length <= 50) {
                      preview = fullText;
                    } else {
                      const truncated = fullText.substring(0, 47);
                      const lastSpace = truncated.lastIndexOf(' ');
                      preview = lastSpace > 20 ? truncated.substring(0, lastSpace) + '...' : truncated + '...';
                    }
                  }
                }
              }
              
              return {
                ...entry,
                content_preview: preview
              };
            });
        } else {
            // Legacy format: parse old structure for backward compatibility
            todaysEntries = [];
            const content = data.content || '';
            
            // Split content by append markers for legacy format
            const sections = content.split(/\n\n\n---\n\*\*Appended at /);
            
            // First section is the original entry
            if (sections[0] && sections[0].trim()) {
              const firstContent = sections[0].trim();
              const words = firstContent.split(/\s+/).filter((w: string) => w.length > 0);
              const preview = firstContent.split('\n')[0] || firstContent || 'Entry 1';
              
              const firstEntry = {
                started_at: frontMatter.date + 'T00:00:00.000Z',
                finished_at: frontMatter.date + 'T00:00:00.000Z',
                duration_seconds: frontMatter.duration_seconds || 0,
                word_count: words.length,
                entry_number: 1,
                content_preview: preview.substring(0, 50)
              };
              todaysEntries.push(firstEntry);
            }
            
            // Parse appended sessions for legacy format
            if (frontMatter.appended_sessions) {
              frontMatter.appended_sessions.forEach((session: any, index: number) => {
                const sectionIndex = index + 1;
                let sectionContent = '';
                
                if (sections[sectionIndex]) {
                  const parts = sections[sectionIndex].split('**\n');
                  if (parts.length > 1) {
                    sectionContent = parts[1].trim();
                  }
                }
                
                const words = sectionContent.split(/\s+/).filter((w: string) => w.length > 0);
                const preview = sectionContent.split('\n')[0] || sectionContent || `Entry ${index + 2}`;
                
                const entry = {
                  started_at: session.timestamp,
                  finished_at: session.timestamp,
                  duration_seconds: session.duration_seconds,
                  word_count: words.length,
                  entry_number: index + 2,
                  content_preview: preview.substring(0, 50)
                };
                todaysEntries.push(entry);
              });
            }
          }
          
          displayPreviousEntries();
        }
      }
    } catch (error) {
      console.error('Error loading today\'s entries:', error);
    }
  }
  
  function displayPreviousEntries() {
    if (!previousEntries) return;
    
    previousEntries.innerHTML = '';
    
    if (todaysEntries.length === 0) {
      previousEntries.innerHTML = '<div class="text-sm text-neutral-500 italic">No entries yet today</div>';
      return;
    }
    
    todaysEntries.forEach((entry, index) => {
      const entryEl = document.createElement('div');
      entryEl.className = 'p-3 bg-neutral-100 dark:bg-neutral-800 rounded-lg cursor-pointer hover:bg-neutral-200 dark:hover:bg-neutral-700 transition';
      
      const startTime = new Date(entry.started_at).toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false,
        timeZone: 'UTC'
      });
      const endTime = new Date(entry.finished_at).toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false,
        timeZone: 'UTC'
      });
      
      const duration = formatDuration(entry.duration_seconds);
      const preview = entry.content_preview || `Entry ${entry.entry_number}`;
      
      entryEl.innerHTML = `
        <div class="flex items-center justify-between text-sm mb-1">
          <span class="font-medium">â–¼ ${startTime}-${endTime}</span>
          <span class="text-neutral-500">(${duration}, ${entry.word_count} words)</span>
        </div>
        <div class="text-xs text-neutral-600 dark:text-neutral-400 truncate">
          "${preview}"
        </div>
      `;
      
      // Add click handler to show entry details (read-only)
      entryEl.addEventListener('click', () => {
        console.log('Entry clicked (read-only):', entry);
        
        // Calculate additional metrics
        const efficiency = entry.total_keystrokes > 0 ? 
          Math.round((entry.total_keystrokes / (entry.total_keystrokes + entry.backspaces)) * 100) : 100;
        const avgPause = entry.pauses && entry.pauses.length > 0 ? 
          Math.round(entry.pauses.reduce((a, b) => a + b, 0) / entry.pauses.length) : 0;
        const wpm = entry.duration_seconds > 0 ? 
          Math.round((entry.word_count / entry.duration_seconds) * 60) : 0;
        
        // Show comprehensive metadata in console
        console.log('ðŸ“Š Entry Metadata:', {
          'â±ï¸ Timing': {
            duration: entry.duration_seconds + 's',
            started: new Date(entry.started_at).toLocaleTimeString(),
            first_keystroke: entry.first_keystroke_at ? 
              new Date(entry.first_keystroke_at).toLocaleTimeString() : 'N/A'
          },
          'âŒ¨ï¸ Typing': {
            keystrokes: entry.total_keystrokes,
            backspaces: entry.backspaces,
            efficiency: efficiency + '%',
            paste_events: entry.paste_events,
            wpm: wpm
          },
          'â¸ï¸ Pauses': {
            count: entry.pauses ? entry.pauses.length : 0,
            max_pause: entry.max_pause + 's',
            avg_pause: avgPause + 's',
            pattern: entry.pauses ? entry.pauses.join('s, ') + 's' : 'none'
          },
          'ðŸ“ Content': {
            words: entry.word_count,
            characters: entry.char_count,
            lines: entry.line_count
          },
          'ðŸ”— Context': {
            entry_number: entry.entry_number,
            time_since_last: entry.time_since_last_entry ? 
              Math.round(entry.time_since_last_entry / 1000) + 's' : 'first entry'
          }
        });
        
        // TODO: Implement read-only entry expansion modal with this data
      });
      
      previousEntries.appendChild(entryEl);
    });
  }
  
  function setupEventListeners() {
    // Focus tracking
    content?.addEventListener('focus', () => {
      if (!entryTracker) {
        entryTracker = new EntryTracker();
        entryTracker.startTracking();
        updateStats();
      }
    });
    
    // Keystroke tracking
    content?.addEventListener('keydown', (e) => {
      if (entryTracker) {
        entryTracker.trackKeystroke(e);
      }
    });
    
    // Paste tracking
    content?.addEventListener('paste', () => {
      if (entryTracker) {
        entryTracker.trackPaste();
      }
    });
    
    // Input tracking for stats
    content?.addEventListener('input', () => {
      updateStats();
    });
    
    // Save button
  saveButton?.addEventListener('click', () => {
      saveEntry();
    });
    
    // Keyboard shortcut (Ctrl/Cmd + Enter)
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
        saveEntry();
      }
    });
    
    // Window focus/blur tracking for background monitoring
    // This ensures we track even when window loses focus (per spec)
    window.addEventListener('blur', () => {
      if (entryTracker) {
        console.log('Window lost focus - continuing tracking in background');
      }
    });
    
    window.addEventListener('focus', () => {
      if (entryTracker) {
        console.log('Window regained focus - tracking continues');
      }
    });
  }
  
  function updateStats() {
    if (!currentStats || !content) return;
    
    const text = content.value;
    const words = text.trim().split(/\s+/).filter(w => w.length > 0);
    const wordCount = words.length;
    
    let duration = '0:00';
    if (entryTracker && entryTracker['metrics'].started_at) {
      const elapsed = Math.floor((Date.now() - new Date(entryTracker['metrics'].started_at).getTime()) / 1000);
      duration = formatDuration(elapsed);
    }
    
    currentStats.textContent = `${wordCount} words, ${duration}`;
  }
  
  function formatDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
  
  async function saveEntry() {
    if (!content || !content.value.trim() || !entryTracker) {
      console.log('No content or tracker to save');
      return;
    }
    
    if (saveStatus) saveStatus.textContent = 'Saving...';
    
    try {
      const contentToSave = content.value.trim();
      const metadata = entryTracker.finishTracking(contentToSave);
      
      const response = await fetch('/api/vault', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'save_entry',
          content: contentToSave,
          metadata: metadata
        })
      });
      
      const responseData = await response.json();
      
      if (response.ok) {
        if (saveStatus) saveStatus.textContent = 'Entry saved';
        
        // Reload entries from server to get the updated list
        await loadTodaysEntries();
        
        // Clear textarea and reset tracker
        content.value = '';
        entryTracker = null;
        updateStats();
        
        setTimeout(() => {
          if (saveStatus) saveStatus.textContent = 'Ready to write';
        }, 2000);
      } else {
        if (saveStatus) saveStatus.textContent = 'Save failed';
        console.error('Save failed:', responseData);
      }
    } catch (error) {
      if (saveStatus) saveStatus.textContent = 'Save error';
      console.error('Save error:', error);
    }
  }
</script>

